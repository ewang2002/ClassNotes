\documentclass[letterpaper]{article}
\input{../../../preamble.tex}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{fancyhdr}
\usepackage[hidelinks]{hyperref}

\pagestyle{fancy}
\fancyhf{}
\rhead{CSE 105}
\chead{Monday, February 7, 2022}
\lhead{Lecture 9}
\rfoot{\thepage}

\setlength{\parindent}{0pt}

\begin{document}

\section{Context-Free Grammars (2.1, Continued)}
We continue our notes on context-free grammars.

\subsection{Relation Between CFGs and Regular Languages}
We know that every regular language is also a context-free language (\emph{however}, not every context-free language is a regular language). There are two approaches to show that this is the case.
\begin{enumerate}
    \item Start with an arbitrary DFA $M$, then build a CFG that generates $L(M)$. 
    \item Build CFGs for $\{\code{a}\}$, $\{\epsilon\}$, and $\emptyset$. Then, show that the class of context-free languages is closed under the regular operations (union, concatenation, Kleene star). 
\end{enumerate}

\subsubsection{First Approach}
\begin{proposition}
    Given any DFA $M$, there is a CFG whose language is $L(M)$. 
\end{proposition}

\begin{mdframed}[]
    \begin{proof}
        Given a DFA $M = (Q, \Sigma, \delta, q_0, F)$, we can define the CFG $G = (V, \Sigma, R, S)$ where 
        \begin{itemize}
            \item $V = \{S_i \mid q_i \in Q\}$
            \item $R = \{S_i \mapsto \code{a}S_j \mid \delta(q_i, \code{a}) = q_j\} \cup \{S_i \mapsto \epsilon \mid q_i \in F\}$
            \item $S = S_0$
        \end{itemize}
        From this, we need to prove correctness.
    \end{proof}
\end{mdframed}

\subsubsection{Second Approach}
We can build CFGs for $\{\code{a}\}$, $\{\epsilon\}$, and $\emptyset$. Then, show that the class of context-free languages is closed under the regular operations (union, concatenation, Kleene star). 

\begin{itemize}
    \item If $L = \{\code{a}\}$, where \code{a} is some arbitrary character in the alphabet, then we have the CFG $(V, \Sigma, R, S)$ where 
    \begin{itemize}
        \item $V = \{S\}$
        \item $R = \{S \mapsto \code{a}\}$
    \end{itemize}
    
    \item If $L = \{\epsilon\}$, then we have the CFG $(V, \Sigma, R, S)$ where 
    \begin{itemize}
        \item $V = \{S\}$
        \item $R = \{S \mapsto \epsilon\}$
    \end{itemize}
    
    \item If $L = \emptyset$, then we have the CFG $(V, \Sigma, R, S)$ where 
    \begin{itemize}
        \item $V = \{S\}$
        \item $R =  \emptyset$ (or $R = \{S \mapsto S\}$)
    \end{itemize} 
\end{itemize}
Suppose we have $G_1 = \{V_1, \Sigma, R_1, S_1\}$ and $G_2 = \{V_2, \Sigma, R_2, S_2\}$, where $G_1$ describes the language $L_1$ and $G_2$ describes the language $L_2$, then we can describe $L_1 \cup L_2$ by combining the grammars to make the grammar $G = (V, \Sigma, R, S)$ where:
\begin{itemize}
    \item $V = V_1 \cup V_2 \cup \{S\}$ (where we assume that $V_1 \cap V_2 = \emptyset$)
    \item $R = R_1 \cup R_2 \cup \{S \mapsto S_1 \mid S_2\}$
\end{itemize}

\subsection{More Examples of CFG Construction}
We now discuss some examples of CFG construction.

\subsubsection{Example 1: Basic Construction}
Build a CFG to describe the language $\{\code{0}^n \code{1}^n \mid n \geq 0\} \cup \{\code{1}^n \code{0}^n \mid n \geq 0\}$. 

\begin{mdframed}[]
    First, construct the grammar for $\{\code{0}^n \code{1}^n \mid n \geq 0\}$. We note that some strings in this grammar are $\epsilon$, \code{01}, \code{0011}, and so on. So, the CFG would be  
    \[S_1 \mapsto \code{0}S_1 \code{1} \mid \epsilon\]
    Likewise, construct the grammar for $\{\code{1}^n \code{0}^n \mid n \geq 0\}$, which gives us 
    \[S_2 \mapsto \code{1}S_2 \code{0} \mid \epsilon\]
    So, our solution is 
    \begin{equation*}
        \begin{aligned}
            S &\mapsto S_1 \mid S_2 \\ 
            S_1 &\mapsto \code{0}S_1 \code{1} \mid \epsilon \\ 
            S_2 &\mapsto \code{1}S_2 \code{0} \mid \epsilon
        \end{aligned}
    \end{equation*}
\end{mdframed}

\subsubsection{Example 2: Advanced Construction}
Build a CFG to describe the langauge $\{0^n 1^m 2^n \mid n, m \geq 0\}$.

\begin{mdframed}[]
    We begin by considering some strings that are generated by this CFG. In particular, we have \code{02}, \code{1}, \code{012}, \code{0112}, \code{00122}, and so on. We know that there are an equal number of \code{0}'s and \code{2}'s, so our start rule must have at least 
    \[S \mapsto \code{0}S\code{2}\]
    What if we have no more $n$ though? We now need to consider the \code{1}s. So, we can create another rule 
    \[T \mapsto \code{1}T\] 
    But, since we can have 0 \code{1}'s, we also need to include the empty string; therefore, our rule for $T$ is 
    \[T \mapsto \code{1}T \mid \epsilon\]
    And, thus, our final set of rules are 
    \[S \mapsto \code{0}S\code{2}\]
    \[T \mapsto \code{1}T \mid \epsilon\]
    To show that this works, note that we will always have the same number of \code{0}'s and \code{2}'s. After we expend all of those, then we can consider some number of \code{1}'s (which we may not necessarily have the same amount of as \code{0}'s and \code{2}'s). Finally, we note that $S$ can map straight to $\epsilon$, implying that the empty string is something that is generated from this language (and, indeed, this is true if $n = m = 0$).
\end{mdframed}

\subsubsection{Example 3: Wild Generations}
Consider the CFG $G = (V, \Sigma, R, S)$ defined by
\begin{itemize}
    \item $V = \{E\}$
    \item $\Sigma = \{\code{1}, +, \times, (, )\}$
    \item $R = \{E \mapsto E + E \mid E \times E \mid (E) \mid \code{1}\}$
    \item $S = E$
\end{itemize}

Which of the following strings is/are generated by this CFG?
\begin{enumerate}[a.]
    \item E
    \item \code{11}
    \item $\code{1} + \code{1} \times \code{1}$
    \item $\epsilon$
\end{enumerate}

\begin{mdframed}[]
    The answer is \textbf{C}. The reason why is because we can perform the following substitutions:
    \begin{equation*}
        \begin{aligned}
            E &\implies E + E && \text{By the first rule.} \\ 
                &\implies \code{1} + E && \text{By the last rule.} \\ 
                &\implies \code{1} + E \times E && \text{By the second rule.} \\ 
                &\implies \code{1} + \code{1} \times E && \text{By the last rule.} \\ 
                &\implies \code{1} + \code{1} \times \code{1} && \text{By the last rule.}
        \end{aligned}
    \end{equation*}
    Note that there are potentially other possible ways this string can be generated. Regardless, the answer is not A because a variable is not a valid string. The answer is not B because there is no way to expand $E$ out twice. The answer is not D because you cannot generate the empty string with the given rules. 
\end{mdframed}

\subsection{Ambiguity}
Sometimes, a grammar can generate the same string in several different ways.
\begin{definition}{}{}
    A string $w$ is derived \textbf{ambiguously} in a context-free grammar $G$ if it has two or more leftmost derivations\footnote{We say that a derivation of a string $w$ in a grammar $G$ is a \textbf{leftmost derivation} if, at every step, the leftmost remaining variable is the one replaced.}. Grammar $G$ is ambiguous if it generates some string ambiguously.
\end{definition}
For example, consider the last example discussed above. There are several ways to derive $\code{1} + \code{1} \times \code{1}$. Some examples are shown below. 
\begin{mdframed}[]
    \begin{itemize}
        \item Derivation 1:
        \begin{equation*}
            \begin{aligned}
                E &\implies E + E && \text{By the first rule.} \\ 
                    &\implies \code{1} + E && \text{By the last rule.} \\ 
                    &\implies \code{1} + E \times E && \text{By the second rule.} \\ 
                    &\implies \code{1} + \code{1} \times E && \text{By the last rule.} \\ 
                    &\implies \code{1} + \code{1} \times \code{1} && \text{By the last rule.}
            \end{aligned}
        \end{equation*}

        \item Derivation 2: 
        \begin{equation*}
            \begin{aligned}
                E &\implies E + E && \text{By the first rule.} \\ 
                    &\implies E + E \times E && \text{By the second rule.} \\ 
                    &\implies 1 + E \times E && \text{By the last rule.} \\ 
                    &\implies 1 + 1 \times E && \text{By the last rule.} \\ 
                    &\implies 1 + 1 \times 1 && \text{By the last rule.}
            \end{aligned}
        \end{equation*}
    \end{itemize}
\end{mdframed}
Note that some context-free languages can be generated only by ambiguous grammars; in this case, we say that these languages are \textbf{inherently ambiguous}.

\subsection{Chomsky Normal Form}
We can use Chomsky normal form to ``simplify'' a context-free grammar. 
\begin{definition}{}{}
    A context-free grammar is in \textbf{Chomsky normal form} if every rule is of the form 
    \begin{equation*}
        \begin{aligned}
            A &\mapsto BC \\ 
            A &\mapsto a
        \end{aligned}
    \end{equation*}
    where a is any terminal and $A, B, C$ are any variables, except that $B$ and $C$ may not be the start variables. In addition, we permit the rule $S \mapsto \epsilon$, where $S$ is the start variable.  
\end{definition}

A somewhat important theorem is as follows:
\begin{theorem}{}{}
    Any context-free language is generated by a context-free grammar in Chomsky normal form. 
\end{theorem}



\end{document}