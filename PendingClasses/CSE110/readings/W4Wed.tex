\documentclass[letterpaper]{article}
\input{../../../preamble.tex}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{fancyhdr}
\usepackage[hidelinks]{hyperref}

\pagestyle{fancy}
\fancyhf{}
\rhead{CSE 110}
\lhead{Week 4 Wednesday}
\rfoot{\thepage}

\setlength{\parindent}{0pt}

\begin{document}
\section{Reading 6: HFSD Ch 7. Testing, pp. 235-251}
There are three ways to look at your system
\begin{itemize}
    \item Your users see the system from the outside: your system is a black box to them, it either does what they asked it to do, or it doesn't. Functionality!
    \item Testers peek under the covers a little: they're poking underneath to make sure things are really happening the way you said they would. Your system is more of a grey box to them. Testers might look at data in your database to make sure things are being cleaned up correctly. They might be checking that ports are closed, network connections are dropped, etc.  
    \item Developers let it all hang out: they see good and bad class design, patterns, duplicated code, inconsistencies in how everything is represented. 
\end{itemize}

\subsection{Black Box Testing Focusing on Input and Output}
\begin{itemize}
    \item Functionality: does the system do what the user story says it's supposed to do.  
    \item User input validation: Feed system values that don't make sense.
    \item Output results: Hand-check numerical values that your system returns. Make sure all functional paths have been tested. 
    \item State transitions: some systems need to move from one state to another according to very specific rules. 
    \item Boundary cases, off-by-one errors: test your system with value that's a little too small or just outside the maximum allowable value. 
\end{itemize}

\subsection{Grey Box Testing Gets You Closer to Code}
\begin{itemize}
    \item Verifying auditing and logging: log viewing tool or auditing report, or query some datbase tables directly. 
    \item Data destined for other systems: check output format and data you're sending. 
    \item System-added information: Make sure system-generated information (e.g., timestamps) are created correctly. 
    \item Scraps left laying around: make sure data is being deleted if it's supposed to be. No memory leaks either. 
\end{itemize}

\subsection{White-Box Testing Uses Inside Knowledge}
\begin{itemize}
    \item Testing all different banches of code: you should look at all code. 
    \item Proper error handling: if you do feed invalid data into a method, are you getting the right error back? 
    \item Working as documented 
    \item Proper handling of resource constraints: what happens if your app needs something it can't get? 
\end{itemize}

\subsection{Coming Up With Tests is Your Job}
\begin{itemize}
    \item Frameworks run your test, not write them. 
    \item You still need to know what you want to test. 
    \item Then, your testing framework choice is going to impact how you test. 
    \item Hanging your tests on a framework 
    \begin{itemize}
        \item Automate tests so we can be more effective
    \end{itemize}
\end{itemize}

\subsection{Testing Everything with One Step}
\begin{enumerate}
    \item Build a suite of tests. 
    \item Run all your tests with one command: the easier it is to run your tests, the better. 
    \item Get regression tests for free: as you add more functionality, your existing tests should still work. If they don't, your software has regressed! 
\end{enumerate}

Tailor your test suites to suit the occasion. So, break out fast and slow tests so developers can run all the fast tests often while they are chaning and adding tests, but only run the full suite when they think they need to. 

\subsection{Automate Tests w/ Testing Framework}
\begin{itemize}
    \item JUnit can be used to test your code. 
    \item Make sure to import it. 
    \item \code{@Before}: called before each test. 
    \item \code{@After}: called after each test. 
\end{itemize}

\end{document}