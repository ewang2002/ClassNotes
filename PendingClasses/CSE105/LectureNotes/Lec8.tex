\documentclass[letterpaper]{article}
\input{../../../preamble.tex}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{fancyhdr}
\usepackage[hidelinks]{hyperref}

\pagestyle{fancy}
\fancyhf{}
\rhead{CSE 105}
\chead{Monday, January 31, 2022}
\lhead{Lecture 8}
\rfoot{\thepage}

\setlength{\parindent}{0pt}

\begin{document}

\section{Context-Free Grammars}
Consider the following context-free grammar $G_1$:
\begin{equation*}
    \begin{aligned}
        A &\mapsto \code{0}A\code{1} \\ 
        A &\mapsto B \\ 
        B &\mapsto \code{\#}
    \end{aligned}
\end{equation*}
Here, we note the following:  
\begin{itemize}
    \item A grammar consists of a collection of \textbf{substitution rules} (also called productions). Each rule appears as a line in the grammar, comprising a symbol and a string separated by an arrow. 
    \item The symbol (e.g. $A$, $B$) is called a \textbf{variable}. They are often represented by capital letters.  
    \item The string consists of variables and other symbols (e.g. \code{0}, \code{1}, \code{\#}) called \textbf{terminals}. They are analogous to the input alphabet and often are represented by lowercase letters, numbers, or other special symbols. In other words, these are symbols that cannot be replaced (substituted). 
    \item One variable, usually (but not always) the top-left one in the list of rules (e.g. $A$), is designated as the \textbf{start variable}.
    \item When we have multiple rules with the same left-hand variable, we may condense them into a single line where the right-hand sides are separated by a \code{|} (as an ``or''). So, we can rewrite the above rules like so: 
    \begin{equation*}
        \begin{aligned}
            A &\mapsto \code{0}A\code{1} \mid B \\
            B &\mapsto \code{\#}
        \end{aligned}
    \end{equation*}
\end{itemize}
We can use a grammar to describe a language by generating each string of that language like so: 
\begin{enumerate}
    \item Write down the start variable. 
    \item Find a variable that is written down and a rule that starts with that variable. Then, replace the written dow nvariable with the right-hand side of that rule. 
    \item Repeat step 2 until no variables remain. 
\end{enumerate}

One \textbf{derivation} (the sequence of substitutions needed to obtain a string) is as follows:
\begin{equation*}
    \begin{aligned}
        A &\implies \code{0}A\code{1} && \text{By first rule.} \\ 
            &\implies \code{00}A\code{11} && \text{By first rule.} \\
            &\implies \code{000}A\code{111} && \text{By first rule.} \\
            &\implies \code{000}B\code{111} && \text{By second rule.} \\
            &\implies \code{000\#111} && \text{By third rule.} \\
    \end{aligned}
\end{equation*}

We say that all strings generated in this way constitute the \textbf{language of the grammar}, and write $L(G)$for the language of grammar $G$. So, for our introductory example above, we have that 
\[L(G_1) = \{\code{0}^n \code{\#} \code{1}^n \mid n \geq 0\}\]
We say that any language that can be generated by some context-free grammar is called a \textbf{context-free language} (CFL). 

\subsection{Formal Definition}
We now introduce the formal definition of a context-free grammar. 
\begin{definition}{}{}
    A \textbf{context-free grammar} is a 4-tuple $(V, \Sigma, R, S)$ where 
    \begin{enumerate}
        \item $V$ is a finite set called the \textbf{variables}.
        \item $\Sigma$ is a finite set, disjoint from $V$, called the \textbf{terminals}.
        \item $R$ is a finite set of \textbf{rules}, with each rule being a variable and a string of variables and terminals.
        \item $S \in V$ is the start variable. 
    \end{enumerate}
\end{definition}
Suppose $u$, $v$, and $w$ are strings of variables and terminals.
\begin{center}
    \begin{tabular}{p{3in}|p{3in}}
        \textbf{Yielding} & \textbf{Deriving} \\ 
        \hline 
        Suppose $A \mapsto w$ is a rule of the grammar. Then, we say that $uAv$ \textbf{yields} $uwv$, written $uAv \implies uwv$. &
        We say that $u$ \textbf{derives} $v$, written $u \stackrel{*}{\implies}$, if $u = v$ or if a sequence $u_1, u_2, \dots, u_k$ exists for $k \geq 0$ and 
        \[u \implies u_1 \implies u_2 \implies \dots \implies u_k \implies v\]
    \end{tabular}
\end{center}
So, it follows that the \textbf{language of the grammar} is given by 
\[\{w \in \Sigma^* \mid S \stackrel{*}{\implies} w\}\]

\subsubsection{Example 1: Identifying Language}
Consider the grammar $G_3 = (\{S\}, \{\code{a}, \code{b}\}, R, S)$, with $R$ being the rule 
\[S \mapsto \code{a}S\code{b} | SS | \epsilon\]
Describe the language of this context-free grammar. 

\begin{mdframed}[]
    This grammar generates strings like \code{abab}, \code{aaabbb}, and \code{aababb}. We can describe the language $L(G_3)$ as all strings where, for any \code{a}, there is a corresponding \code{b}. Analogously, if we let \code{a} be \code{(} and \code{b} be \code{)}, then this is the language of all properly nested parentheses. 
\end{mdframed}

\subsection{Describing Context-Free Languages}
Many context-free languages are the union of simpler context-free languages. So, if you need to construct a context-free grammar for a context-free language, break it into simpler pieces, create the corresponding grammars, and then merge them into a grammar for the original language by combining their rules and then adding the new rule 
    \[S \mapsto S_1 \mid S_2 \mid \dots \mid S_k\]
where the variables $S_i$ are the start variables for the individual grammars. 

\subsubsection{Example 1: Constructing Context-Free Grammar}
Build a CFG to describe the language $\{\code{abba}\}$. 

\begin{mdframed}[]
    There are several ways to go about this. Consider
    \[G_a = (\{S\}, \{\code{a}, \code{b}\}, \{S \mapsto \code{abba}\}, S)\]
    which maps $S$ to \code{abba}, exactly what we wanted. 

    \bigskip 

    Another example is 
    \[G_b = (\{S, T, V, W\}, \{\code{a}, \code{b}\}, R, S)\]
    where $R$ is defined by the rules 
    \begin{equation*}
        \begin{aligned}
            S &\mapsto \code{a}T \\ 
            T &\mapsto \code{b}V \\ 
            V &\mapsto \code{b}W \\ 
            W &\mapsto \code{a}
        \end{aligned}
    \end{equation*}
    So, if we applied the substitution rules, we would get 
    \begin{equation*}
        \begin{aligned}
            S &\mapsto \code{aT} && \text{By first rule.} \\ 
                &\mapsto \code{ab}V && \text{By second rule.} \\ 
                &\mapsto \code{abb}W && \text{By third rule.} \\ 
                &\mapsto \code{abba} && \text{By fourth rule.}
        \end{aligned}
    \end{equation*}
\end{mdframed}

\subsubsection{Example 2: Constructing Context-Free Grammar}
Build a CFG to describe the language $\{\code{0}^n \code{1}^n \mid n \geq 0\} \cup \{\code{1}^n \code{0}^n \mid n \geq 0\}$. 

\begin{mdframed}[]
    First, construct the grammar for $\{\code{0}^n \code{1}^n \mid n \geq 0\}$. We note that some strings in this grammar are $\epsilon$, \code{01}, \code{0011}, and so on. So, the CFG would be  
    \[S_1 \mapsto \code{0}S_1 \code{1} \mid \epsilon\]
    Likewise, construct the grammar for $\{\code{1}^n \code{0}^n \mid n \geq 0\}$, which gives us 
    \[S_2 \mapsto \code{1}S_2 \code{0} \mid \epsilon\]
    So, our solution is 
    \begin{equation*}
        \begin{aligned}
            S &\mapsto S_1 \mid S_2 \\ 
            S_1 &\mapsto \code{0}S_1 \code{1} \mid \epsilon \\ 
            S_2 &\mapsto \code{1}S_2 \code{0} \mid \epsilon
        \end{aligned}
    \end{equation*}
\end{mdframed}


\end{document}