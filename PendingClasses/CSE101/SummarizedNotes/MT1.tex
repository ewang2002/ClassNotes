\documentclass[letterpaper]{article}
\input{../../../preamble.tex}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{fancyhdr}
\usepackage[hidelinks]{hyperref}

\pagestyle{fancy}
\fancyhf{}
\rhead{CSE 101}
\chead{Thursday, January 20, 2022}
\lhead{Midterm 1 Notes}
\rfoot{\thepage}

\setlength{\parindent}{0pt}

\begin{document}

\newpage 

\pagenumbering{gobble}
\begingroup
    \renewcommand\contentsname{Table of Contents}
    \tableofcontents
\endgroup

\newpage
\pagenumbering{arabic}

\section{Undirected Graph: The Basics}
\begin{definition}{Graph}{}
    An (undirected) \textbf{graph} $G = (V, E)$ consists of two things:
    \begin{itemize}
        \item A collection $V$ of vertices, or objects, to be connected.
        \item A collection $E$ of edges, each of which connects a pair of vertices.
    \end{itemize}
\end{definition}

\subsection{Exploring an Undirected Graph}
We can make use of an \code{explore} algorithm to explore all vertices that can be reached from a particular vertex $v$. In particular, we can use a field \code{v.visited} to let us know which vertices we've already checked.
\begin{verbatim}
    explore(v):
        v.visited <- true 
        for each edge (v, w):
            if not w.visited:
                explore(w)
                w.prev <- v     // If we want to keep track of path taken
\end{verbatim}
This algorithm runs in $\BigO(|V|)$ time. This is because we may potentially explore every vertex in the graph. 

\begin{theorem}{}{}
    If all vertices start unvisited, \code{explore(v)} marks as visited exactly the vertices reachable from \code{v}.
\end{theorem}


\subsection{Depth First Search}
\code{explore} only finds the part of the graph reachable from a single vertex. If you want to discover the entire graph, you may need to run it multiple times. This introduces an algorithm known as \textbf{depth-first search}:
\begin{verbatim}
    DepthFirstSearch(v):
        Mark all v in G as unvisited. 
        For v in G:
            if not v.visited:
                explore(v)
\end{verbatim}
The final runtime is $\BigO(|V| + |E|)$. 

\subsection{Connected Components}
\begin{theorem}{}{}
    The vertices of a graph $G$ can be partitioned into connected components so that $v$ is is reachable from $w$ if and only if they are in the same connected component. 
\end{theorem}

We can use depth-first search to find the connected components:
\begin{verbatim}
    explore(v):
        v.visited = true 
        // CC is connected components
        v.CC = CCNum 
        for each edge (v, w):
            if not w.visited: 
                explore(w)

    ConnectedComponents(G):
        CCNum = 0
        for each v in G:
            v.visited = false
        for each v in G: 
            if not v.visited: 
                CCNum++
                explore(v, CCNum)
\end{verbatim}
This runs in $\BigO(|V| + |E|)$. 

\subsection{Pre- \& Post-Order Numbers}
We can augment DFS to keep track of what the algorithm does and how it does it. In particular, we can have a ``clock'' and note the time whenever:
\begin{itemize}
    \item The algorithm visits a new vertex for the first time. 
    \item The algorithm finishes processing a vertex.
\end{itemize}
These can be recorded as \code{v.pre} and \code{v.post}. The algorithm is as follows:
\begin{verbatim}
    explore(v)
        v.visited = true 
        v.pre = clock 
        clock++
        For each edge (v, w)
            If not w.visited
                explore(w)
        v.post = clock 
        clock++

    DepthFirstSearch(G)
        clock = 1
        Mark all v in G as unvisited
        For v in G
            If not v.visited
                explore(v)
\end{verbatim}
This runs in $\BigO(|V| + |E|)$. 

\subsubsection{Interpretation of Pre- \& Post-Order Numbers}
\begin{proposition}
    For vertices $v$, $w$, we can consider the intervals \code{[v.pre, v.post]} and \code{[w.pre, w.post]}. These intervals:
    \begin{enumerate}
        \item contain each other if $v$ is an ancestor/descendant of $w$ in the DFS tree. 
        \item are disjoint if $v$ and $w$ are cousins in the DFS tree.
        \item never interleave (\code{v.pre < w.pre < v.post < w.post}).
    \end{enumerate}
\end{proposition}


\newpage 
\section{Directed Graph: The Basics}
\begin{definition}{}{}
    A \textbf{directed graph} is a graph where each edge has a direction. We say that it goes from $v$ to $w$. 
\end{definition}
Often, we draw arrows on the edges to denote direction. 

\subsection{DFS on Directed Graph}
We can use DFS on a directed graph. There are a few notes to consider:
\begin{itemize}
    \item It's the same code. 
    \item We only follow directed edges from $v$ to $w$. 
    \item The runtime is still $\BigO(|V| + |E|)$. 
    \item \code{explore(v)} discovers all vertices reachable from $v$ following only directed edges. 
\end{itemize}

\subsection{Topological Ordering}
Essentially, a directed graph can be thought of as a graph of dependencies. An edge $v \mapsto w$ means that $v$ should come before $w$. We can use something known as topological ordering to better understand this relationship.

\begin{definition}{Topological Ordering}{}
    A \textbf{topological ordering} of a directed graph is an ordering of the vertices so that for each edge $(v, w)$, $v$ comes before $w$ in the ordering.
\end{definition}
\textbf{Remark:} There can be multiple different topological orderings for the same graph.

\subsubsection{Cycles}
\begin{definition}{Cycle}{}
    A cycle in a directed graph is a sequence of vertices $v_1, v_2, \dots, v_n$ so that there are edges: 
    \[(v_1, v_2), (v_2, v_3), \dots, (v_n, v_1)\]
\end{definition}

\subsubsection{Obstacle}
\begin{proposition}
    If $G$ is a directed graph with a cycle, then $G$ has no topological ordering.
\end{proposition}
So, in other words, if $G$ is a directed graph with at least one cycle \emph{anywhere}, then it has no topological ordering.

\subsubsection{Directed Acyclic Graph}
Suppose we want to focus on directed graphs with no cycles. This brings us to the following definition:
\begin{definition}{}{}
    A \textbf{directed acylic graph} (DAG) is a directed graph which contains no cycles. 
\end{definition}
\textbf{Remark:} Every DAG has a topological ordering. 

\subsubsection{Existence of Orderings}
\begin{theorem}{}{}
    Let $G$ be a (finite) DAG. Then, $G$ has a topological ordering.
\end{theorem}

\begin{lemma}{}{}
    Every finite DAG contains at least one sink. 
\end{lemma}
\textbf{Remark:}
\begin{itemize}
    \item A \textbf{sink vertex} is a vertex with no outgoing edges.
    \item A \textbf{source vertex} is a vertex with no incoming edges.
\end{itemize}


\subsubsection{Algorithm}
The algorithm for finding a topological ordering of a \underline{directed acyclic graph} $G$ is:
\begin{verbatim}
    TopologicalOrdering(G)
        Run DFS(G) w/ Pre/Post Numbers 
        Return Vertices in Reverse Postorder
\end{verbatim}
The runtime is $\BigO(|V| + |E|)$. 

\subsection{Strongly Connected Components}
\begin{definition}{Strongly Connected Components}{}
    In a directed graph $G$, two vertices $v$ and $w$ are in the same \textbf{strongly connected component} if $v$ is reachable from $w$ and $w$ is reachable from $v$.
\end{definition}

\subsubsection{Equivalence Relation}
Let $v \sim w$ if $v$ is reachable from $w$ and vice versa.
\begin{proposition}
    This is an equivalence relation. Namely:
    \begin{itemize}
        \item $v \sim v$ ($v$ is reachable from itself).
        \item $v \sim w \implies w \sim v$ (relation is symmetric).
        \item $u \sim v \text{ and } v \sim w \implies u \sim w$.
    \end{itemize}
\end{proposition}

Essentially, when we have this equivalence relation, we can split a set into components (equivalence classes) so that $v \sim w$ if and only if $v$ and $w$ are in the same component.

\subsubsection{Metagraph}
\begin{definition}{Metagraph}{}
    The \textbf{metagraph} of a directed graph $G$ is a graph whose vertices are the strongly connected components of $G$, where there is an edge between $C_1$ and $C_2$ if and only if $G$ has an edge between some vertex of $C_1$ and some vertex of $C_2$. 
\end{definition}
\textbf{Remark:} If you're given the strongly connected components and the metagraph of a graph $G$, then you can you can figure out connectivity within the full graph.


\subsubsection{Result of the Metagraph}
\begin{theorem}{}{}
    The metagraph of any directed graph is a DAG. 
\end{theorem}

\subsubsection{Computing Strongly Connected Components}
Given a directed graph $G$, compute the SCCs of $G$ and its metagraph. 
\begin{itemize}
    \item Find $v$ in a sink SCC of $G$. 
    \item Run \code{explore(v)} to find the component $C_1$.
    \item Repeat process on $G \setminus C_1$.
\end{itemize}

\subsubsection{Result}
\begin{proposition}
    Let $C_1$ and $C_2$ be SCCs of $G$ with an edge from $C_1$ to $C_2$. If we run \code{DFS} on $G$, the largest postorder number of any vertex in $C_1$ will be larger than the largest postorder number in $C_2$. 
\end{proposition}
The reason why we care is because if $v$ is the vertex with the largest postorder number, then: 
\begin{itemize}
    \item There is no edge to $SCC(V)$ from any other SCC. 
    \item SCC is a \underline{source} SCC.
\end{itemize}
However, we wanted a \emph{sink} SCC. So, how do we relate these two?
\begin{itemize}
    \item A sink is like a source, only with edges going in the opposite direction.
\end{itemize}


\subsubsection{Reverse Graph}
\begin{definition}{Reverse Graph}{}
    Given a directed graph $G$, the \textbf{reverse graph} of $G$ (denoted $G^R$) is obtained by reversing the directions of all the edges of $G$.
\end{definition}
Some properties of reverse graphs are: 
\begin{itemize}
    \item $G$ and $G^R$ have the same number of vertices and edges. 
    \item $G = (G^R)^R$. 
    \item $G$ and $G^R$ have the same SCCs. 
    \item The sink SCCs of $G$ are the source SCCs of $G^R$. 
    \item The source SCCs of $G$ are the sink SCCs of $G^R$. 
\end{itemize}

\subsubsection{Algorithm}
\begin{verbatim}
    SCCs(G)
        Run DFS(G^R), record postorders
        Mark all vertices as unvisited 
        For v in V in reverse postorder 
            If v not in a component yet     // if v is not visited 
                explore(v) on G-components found,
                marking new component 
\end{verbatim}
This runs in $\BigO(|V| + |E|)$ time. 



\newpage 
\section{Breadth-First Search}
Given a graph $G$ with two vertices $s$ and $t$ in the same connected component, how do we find the \emph{best} path from $s$ to $t$? In fact, what do we mean by the best path? 
\begin{itemize}
    \item Least expensive. 
    \item Best scenery.
    \item Shortest.
\end{itemize}
For now, we want the \textbf{fewest edges}. 

\subsection{Observation}
\begin{proposition}
    If there is a path from vertices $s$ to $v$ with length at most $d$, then there is some $w$ adjacent to $v$ where there is a path a length at most $(d - 1)$ from vertices $s$ to $w$.
\end{proposition} 

\subsection{Algorithm}
\begin{verbatim}
    BFS(G, s)
        For v in V, dist(v) = infinity 
        Initialize Queue Q
        Q.enqueue(s)
        dist(s) = 0
        While Q is not empty
            u = front(Q)
            For (u, v) in E
                If dist(v) = infinity
                    dist(v) = dist(u) + 1
                    Q.enqueue(v)
                    v.prev = u
\end{verbatim}
\begin{itemize}
    \item This runs in $\BigO(|V| + |E|)$ time. 
    \item $d(v)$ means the distance of vertex $v$ whereas $d(v, w)$ means the length of the edge between $v$ and $w$. 
\end{itemize}

\subsection{Differences Between DFS and BFS}
\begin{itemize}
    \item Similarities:
    \begin{itemize}
        \item The way both algorithms process vertices is the same (\code{visited} for DFS vs. \code{dist < infinity} for BFS).
        \item For each vertex, process all unprocessed neighbors.
    \end{itemize}
    \item Differences:
    \begin{itemize}
        \item DFS uses a stack to store vertices waiting to be processed. 
        \item BFS uses a queue.
    \end{itemize}
    \item Big Effect:
    \begin{itemize}
        \item DFS goes depth-first: very long path. Get a very ``skinny'' tree. 
        \item BFS is breadth first: visits all side paths. Get a very shallow tree since we process all of the neighbors.
    \end{itemize}
\end{itemize}


\newpage 
\section{Key Algorithms}
Below are some key algorithms that we have discussed in lecture.

\subsection{Algorithm: Explore}
\begin{center}
    \begin{tabular}{|c|c|}
        \hline 
        \textbf{Category} & \textbf{Answer} \\ 
        \hline 
        Graph Type & Undirected, Directed \\ 
        Runtime & $\BigO(|V| + |E|)$ \\ 
        \hline 
    \end{tabular}
\end{center}

\begin{itemize}
    \item Explore a particular (strongly) connected component, or the entire graph if the graph is connected. 
\end{itemize}

\begin{mdframed}[]
    \begin{verbatim}
        explore(v):
            v.visited <- true 
            for each edge (v, w):
                if not w.visited:
                    explore(w)
                    w.prev <- v     // If we want to keep track of path taken\end{verbatim}
\end{mdframed}


\subsection{Algorithm: Depth-First Search}
\begin{center}
    \begin{tabular}{|c|c|}
        \hline 
        \textbf{Category} & \textbf{Answer} \\ 
        \hline 
        Graph Type & Undirected, Directed \\ 
        Runtime & $\BigO(|V| + |E|)$ \\ 
        \hline 
    \end{tabular}
\end{center}

\begin{mdframed}[]
    \begin{verbatim}
        DepthFirstSearch(v):
            Mark all v in G as unvisited. 
            For v in G:
                if not v.visited:
                    explore(v)\end{verbatim}
\end{mdframed}


\subsection{Algorithm: Connected Components}
\begin{center}
    \begin{tabular}{|c|c|}
        \hline 
        \textbf{Category} & \textbf{Answer} \\ 
        \hline 
        Graph Type & Undirected \\ 
        Runtime & $\BigO(|V| + |E|)$ \\ 
        \hline 
    \end{tabular}
\end{center}

\begin{itemize}
    \item Find all connected components of an undirected graph. 
\end{itemize}

\begin{mdframed}[]
    \begin{verbatim}
        explore(v, CCNum):
            v.visited = true 
            // CC is connected components
            v.CC = CCNum 
            for each edge (v, w):
                if not w.visited: 
                    explore(w)
    
        ConnectedComponents(G):
            CCNum = 0
            for each v in G:
                v.visited = false
            for each v in G: 
                if not v.visited: 
                    CCNum++
                    explore(v, CCNum)\end{verbatim}
\end{mdframed}


\subsection{Algorithm: Pre- \& Post-Order Numbers}
\begin{center}
    \begin{tabular}{|c|c|}
        \hline 
        \textbf{Category} & \textbf{Answer} \\ 
        \hline 
        Graph Type & Undirected, Directed \\ 
        Runtime & $\BigO(|V| + |E|)$ \\ 
        \hline 
    \end{tabular}
\end{center}

\begin{itemize}
    \item For a directed graph $G$, for any DFS on $G$, the vertex with highest post-order number lies in a source SCC. Regardless of where you start counting, the vertex with the largest post-order number in a directed graph is \emph{a} source\footnote{Alternatively, a source vertex does not have any incoming edges.}.
    \item If $G$ is our graph and $G^R$ is the reverse graph, then the vertex with the highest post-order number in the reverse graph is the \emph{sink} of $G$. 
\end{itemize}

\begin{mdframed}[]
    \begin{verbatim}
        explore(v)
            v.visited = true 
            v.pre = clock 
            clock++
            For each edge (v, w)
                If not w.visited
                    explore(w)
            v.post = clock 
            clock++
    
        DepthFirstSearch(G)
            clock = 1
            Mark all v in G as unvisited
            For v in G
                If not v.visited
                    explore(v)\end{verbatim}
\end{mdframed}


\subsection{Algorithm: Topological Ordering}
\begin{center}
    \begin{tabular}{|c|c|}
        \hline 
        \textbf{Category} & \textbf{Answer} \\ 
        \hline 
        Graph Type & Directed (Acyclic) \\ 
        Runtime & $\BigO(|V| + |E|)$ \\ 
        \hline 
    \end{tabular}
\end{center}

\begin{mdframed}[]
    \begin{verbatim}
        TopologicalOrdering(G)
            Run DFS(G) w/ Pre/Post Numbers 
            Return Vertices in Reverse Postorder\end{verbatim}
\end{mdframed}


\subsection{Algorithm: Strongly Connected Components}
\begin{center}
    \begin{tabular}{|c|c|}
        \hline 
        \textbf{Category} & \textbf{Answer} \\ 
        \hline 
        Graph Type & Directed \\ 
        Runtime & $\BigO(|V| + |E|)$ \\ 
        \hline 
    \end{tabular}
\end{center}

\begin{itemize}
    \item Used to compute the metagraph, which can then be used to find the source/sink components. 
\end{itemize}

\begin{mdframed}[]
    \begin{verbatim}
        SCCs(G)
            Run DFS(G^R), record postorders
            Mark all vertices as unvisited 
            For v in V in reverse postorder 
                If v not in a component yet     // if v is not visited 
                    explore(v) on G-components found,
                    marking new component \end{verbatim}
\end{mdframed}

\subsection{Algorithm: Breadth-First Search}
\begin{center}
    \begin{tabular}{|c|c|}
        \hline 
        \textbf{Category} & \textbf{Answer} \\ 
        \hline 
        Graph Type & Undirected, Directed \\ 
        Runtime & $\BigO(|V| + |E|)$ \\ 
        \hline 
    \end{tabular}
\end{center}

\begin{itemize}
    \item Finds the shortest distance between two vertices, assuming the edges are unweighted.
    \item Define $d(v)$ to be the (shortest) length of the path from the starting vertex to $v$. 
    \item Define $d(v, w)$ to be the (shortest) length of the path from $v$ to $w$. 
\end{itemize}

\begin{mdframed}[]
    \begin{verbatim}
        BFS(G, s)
            For v in V, dist(v) = infinity 
            Initialize Queue Q
            Q.enqueue(s)
            dist(s) = 0
            While Q is not empty
                u = front(Q)
                For (u, v) in E
                    If dist(v) = infinity
                        dist(v) = dist(u) + 1
                        Q.enqueue(v)\end{verbatim}
\end{mdframed}

\end{document}
