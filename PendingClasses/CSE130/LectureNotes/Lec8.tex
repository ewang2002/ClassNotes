\documentclass[letterpaper]{article}
\input{../../../preamble.tex}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{fancyhdr}
\usepackage[hidelinks]{hyperref}

\pagestyle{fancy}
\fancyhf{}
\rhead{CSE 130}
\chead{Wednesday, April 13, 2022}
\lhead{Lecture 8}
\rfoot{\thepage}

\setlength{\parindent}{0pt}

\begin{document}

\section{Haskell: An Introduction}
\textbf{Haskell} is essentially Lambda Calculus plus
\begin{itemize}
    \item Better syntax. 
    \item Types.
    \item Built-in features like primitives (booleans, numbers, etc.), records, lists, recurison, and more.
\end{itemize}

\subsection{Types}
In Haskell, every expression either \textbf{has a type} or is \textbf{ill-typed} and rejected statically (at compile-time, before execution begins). This is similar to Java (which is statically typed), and differs from languages like Python (which is dynamically typed).

\subsubsection{Type Annotations}
While the Haskell compiler can infer types, you should still annotate your bindings with their types using \code{::}, like so: 
\begin{verbatim}
    aBoolean :: Bool 
    aBoolean = True 

    message :: String 
    message = if aBoolean
                then "True!"
                else "False."

    rating :: Int 
    rating = if aBoolean
                then 10 
                else 0
\end{verbatim}
Note that we can use the GHCi command \code{:t} to inspect types. For example, 
\begin{verbatim}
    > :t if x then 'a' else 'b'             -- Char 
    > :t \b -> if b then 'a' else 'n'       -- Bool -> Char 
\end{verbatim}
Note that we can also have functions with mulitple parameters; that is:
\begin{verbatim}
    pair :: String -> (String -> (Bool -> String))  
    pair :: String -> String -> Bool -> String      -- Same as above. 
    pair x y z = if b then x else y                 -- Definition of function.
\end{verbatim}

\section{Lists}
A list is either: 
\begin{itemize}
    \item An empty list
    \begin{verbatim}
        []              -- pronounced "nil"\end{verbatim}

    \item Or a head element attached to a tail list.
    \begin{verbatim}
        x:xs            -- pronounced "x cons xs"\end{verbatim}
\end{itemize}
So, for example, we have: 
\begin{verbatim}
    []                              -- A list with 0 elements. 
    1:[]                            -- A list with 1 element. 
    (:) 1 []                        -- Same thing 
    1:(2:(3:(4:([]))))              -- A list with 4 elements. 
    1:2:3:4:[]                      -- Same thing (: is right associative)
    [1, 2, 3, 4]                    -- Same thing (syntactic sugar)
\end{verbatim}

\end{document}