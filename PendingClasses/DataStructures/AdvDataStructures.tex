\documentclass[letterpaper]{article}
\input{../../preamble.tex}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{fancyhdr}
\usepackage[hidelinks]{hyperref}

\pagestyle{fancy}
\fancyhf{}
\rhead{CSE 100}
\chead{September 14th, 2021}
\lhead{Course Notes}
\rfoot{\thepage}

\setlength{\parindent}{0pt}

\begin{document}

\begin{titlepage}
    \begin{center}
        \vspace*{1cm}
            
        \Huge
        \textbf{CSE 100 Notes}
            
        \vspace{0.5cm}
        \LARGE
        Advanced Data Structures
            
        \vspace{1.5cm}
            
        \vfill
            
        Fall 2021\\
        Taught by Professor Niema Moshiri
    \end{center}
\end{titlepage}

\pagenumbering{gobble}

\newpage 

\pagenumbering{gobble}
\begingroup
    \renewcommand\contentsname{Table of Contents}
    \tableofcontents
\endgroup

\newpage
\pagenumbering{arabic}


% ======================================================== %
%                   NEW SECTION                            %
% ======================================================== %
\section{A Brief Introduction}
In this course, we will primarily be building off of our prior knowledge of data structures (CSE 12). In particular, we will: 
\begin{itemize}
    \item Analyze data structures for both time and space complexity. 
    \item Describe the strengths and weaknesses of a data structure. 
    \item Implement complex data structures correctly and efficiently. 
\end{itemize}


% https://www.youtube.com/watch?v=_vpy1Flh__4&list=PLM_KIlU0WoXmkV4QB1Dg8PtJaHTdWHwRS&index=2
\subsection{Data Structures vs. Abstract Data Types}
When talking about data, we often hear about data structures and abstract data types. 

\begin{center}
    \begin{tabular}{|p{7cm}|p{7cm}|}
        \hline 
        \textbf{Data Structures} (DS) & \textbf{Abstract Data Type} (ADT) \\
        \hline 
        Data structures are collections that contain: 
        \begin{itemize}
            \item Data values. 
            \item Relationships among the data. 
            \item Operations applied to the data. 
        \end{itemize}
        It also describes how the data are organized and how tasks are performed. So, a data structure defines every single detail about anything relating to the data. 
        &
        Abstract data types are defined primarily by its \underline{behavior} from the view of the \underline{user}. So, not necessarily how the operations are done, but rather what operations it must have from a completely abstract point of view.  
    
        \bigskip 
    
        Specifically, it describes only what needs to be done, not how it's done. \\
        \hline 
    \end{tabular}
\end{center}

Consider the \code{ArrayList} (DS) vs. the \code{List} (ADT).
\begin{itemize}
    \item A \code{List} will most likely have the following operations: 
    \begin{itemize}
        \item \code{add}: Adds an element to the list.
        \item \code{find}: Does an element exist in the list? 
        \item \code{remove}: Remove an element from the list. 
        \item \code{size}: How many elements are in this list? 
        \item \code{ordered}: Each element should be ordered in the way we added it. For example, if we added \code{5}, and \emph{then} added \code{3}, and \emph{then} added \code{10}, our list should look like: \code{[5, 3, 10]}.   
    \end{itemize}

    Of course, as an abstract data type, \code{List} isn't going to define how these operations work. It just lists all operations that any implementing data structure must have. In other words, we can think of \code{List}, or any abstract data type, as a \emph{blueprint} for future data structures. 

    \item An \code{ArrayList} is simply an array that is expandable. It is internally backed by an \underline{array}. So, we can perform the following operations: 
    \begin{itemize}
        \item We can \code{add} an element to the \code{ArrayList}. In this case, we add the element to the next available slot in the array, expanding the array if necessary. 
        \item We can \code{find} an element in the \code{ArrayList}. In this case, we can search through each slot of the array until we find the array or we reach the end of the array.
        \item We can \code{remove} an element from the \code{ArrayList}. In this case, we can simply move every element after the specified element back one slot. 
        \item We can get the \code{size} of the \code{ArrayList}. In this case, this is as simple as seeing how many elements are in this \code{ArrayList}.
        \item And, we know that the \code{ArrayList} is \code{ordered}. In this case, this is already done via the \code{add} and \code{remove} methods.  
    \end{itemize}
    Notice how \code{ArrayList} specifies how each operation defined by \code{List} works. In this sense, we say that \code{ArrayList} essentially implements \code{List} because we need to define \emph{how} the tasks defined by \code{List} are performed. 
\end{itemize}
So, the key takeaways are: 
\begin{itemize}
    \item An abstract data type (in our case, \code{List}) specifies what needs to be done without specifying how it's done. 
    \item A data structure (in our case, \code{ArrayList}) actually defines \textbf{how} the data is organized, how the different operations are performed, and how exactly everything is represented.
\end{itemize}











% ======================================================== %
%                   NEW SECTION                            %
% ======================================================== %
\newpage 
\section{Introduction to C++}
Here, we will talk about C++, the programming language that we will use in this course. 

% https://www.youtube.com/watch?v=8FGvlugzS5A&list=PLM_KIlU0WoXmkV4QB1Dg8PtJaHTdWHwRS&index=4
\subsection{Data Types}
First, we'll compare the data types in Java and C++. 
\begin{center}
    \begin{tabular}{|c|c|c|}
        \hline 
        \textbf{Data Type} & \textbf{Java} & \textbf{C++} \\ 
        \hline 
        \code{byte} & 1 byte & 1 byte \\ 
        \code{short} & 2 bytes & 2 bytes \\ 
        \code{int} & 4 bytes & 4 bytes \\ 
        \code{long} & 8 bytes & 8 bytes \\ 
        \code{long long} & & 16 bytes \\ 
        \hline 
        \code{float} & 4 bytes & \code{4 bytes} \\ 
        \code{double} & 8 bytes & \code{8 bytes} \\ 
        \hline 
        \code{boolean} & Usually 1 byte & \\ 
        \code{bool} &  & Usually 1 byte \\ 
        \code{char} & 2 bytes & 1 byte \\ 
        \hline 
    \end{tabular}
\end{center}
It should be mentioned that: 
\begin{itemize}
    \item In Java, you can only have signed data types. 
    \item In C++, you can have both signed and unsigned data types. 
    \item \code{boolean} (Java) and \code{bool} (C++) are effectively the same thing: they represent either \code{true} or \code{false}. 
\end{itemize}

\subsection{Strings}
There are some major differences between strings in Java and C++, which we will discuss below.

\subsubsection{Representation}
In Java, strings are represented by the \code{String} class. In C++, strings are represented by the \code{string} type.

\subsubsection{Mutability}
Strings in Java are \underline{immutable}. The moment you create a string, you won't be able to modify them. The only way to change a string variable is by creating a new string and reassigning them. 

\bigskip 

In C++, strings are actually \underline{mutable}. You can modify strings in-place. 

\subsubsection{Concatenation}
In Java, you can concatenate any type to a string. For example, the following is valid:
\begin{verbatim}
    String a = "this is a string" + 123;\end{verbatim}

In C++, you can only concatenate strings with other strings. So, if you wanted to convert an integer (or any other type) to a string, you would have to \emph{first} convert that integer to a string (or use a string stream).

\subsubsection{Substring Method}
In Java, we can take the substring of a string using the \code{substring} method. The method signature is:
\begin{verbatim}
    String#substring(beginIndex, endIndex);\end{verbatim}

In C++, we can take the substring using the \code{substr} method. The method signature is:
\begin{verbatim}
    string#substr(beginIndex, length);\end{verbatim}

An important distinction to make here is that Java's \code{substring} method takes in an \textbf{end index} for the second parameter, whereas C++'s \code{substr} method takes in a \textbf{length} for the second parameter.



\subsection{Comparing Non-Primitive Objects}
Suppose \code{a} and \code{b} are two non-primitive objects.

\bigskip 

In Java, if we want to compare these two objects, we have to make use of the methods: 
\begin{verbatim}
    a.equals(b)
    a.compareTo(b)
\end{verbatim}
If we tried using the relational operators like \code{==} or \code{!=}, Java would compare the memory addresses of the two objects, which is often something that we aren't looking for.

\bigskip 

In C++, even if \code{a} and \code{b} are objects, we can make use of the relational operators:
\begin{verbatim}
    a == b      a != b
    a < b       a <= b
    a > b       a >= b
\end{verbatim}
This is done through something called \textbf{operator overloading}, where we write a custom class and define how these operators should function.


\subsection{Variables}
Now, we will briefly discuss how variables function in both C++ and Java. 

\subsubsection{Initialization}
In Java, variable initialization is \textbf{checked}. Consider the following code: 
\begin{verbatim}
    int fast;
    int furious; 
    int fastFurious = fast + furious;
\end{verbatim}
Because \code{fast} and \code{furious} aren't initialized, the Java compiler will throw a compilation error. 

\bigskip 

In C++, variable initialization is \textbf{not checked}. Consider the same code, which will compile:
\begin{verbatim}
    int fast;
    int furious; 
    int fastFurious = fast + furious;
\end{verbatim}
Here, this would result in \textbf{undefined} behavior.

\subsubsection{Narrowing}
In Java, if we have a higher variable type and then try to cast this type to a smaller type, we would get a compilation error. Consider the following code:
\begin{verbatim}
    int x = 40_000;
    short y = x;
\end{verbatim}
This code would result in a compilation error. If we didn't want a compilation error, we would have to explicitly \emph{cast} the bigger variable type to the smaller type. The following Java code would compile just fine: 
\begin{verbatim}
    int x = 40_000;
    short y = (short) x;
\end{verbatim}

\bigskip 

In C++, no compilation error would occur; that is, the following code would compile:
\begin{verbatim}
    int x = 40_000;
    short y = x;
\end{verbatim}
What would actually happen is that \code{x} would get \textbf{truncated} when it is assigned to \code{y}, resulting in integer overflow. 


\subsubsection{Variable Declaration}
In Java, variables \textbf{cannot} be declared outside of a class. The following Java code would result in a compile error:
\begin{verbatim}
    // MyClass.java 

    int meaningOfLife = 42;
    class MyClass {
        // some code 
    }
\end{verbatim}
In order for this to compile, you have to put variable declarations inside the class space (as an instance variable) or in a method inside a class (as a local variable). 

\bigskip 

In C++, variables \textbf{can} be declared outside of a class. The following C++ code would compile completely fine: 
\begin{verbatim}
    // MyClass.cpp

    int meaningOfLife = 42;
    class MyClass {
        // some code 
    }
\end{verbatim}
Here, \code{meaningOfLife} is a \textbf{global variable}. Anything in this file can access this variable. In general, it is considered poor practice to use global variables except in cases of constants. 

\subsection{Classes, Source Code, and Headers}
Another thing that is important is the concept of classes (which leads to the topic of object-oriented programming). That being said, Java and C++ has some differences with regards to how classes function. 

\subsubsection{Class Declaration}
There are some key differences in how methods and instance variables are laid out in Java and C++. 

In Java, a typical class would look like: 
\begin{verbatim}
    class Student {
        public static int numStudents = 0;
        private String name; 
        
        public Student(String n) { /* Code */ }

        public void setName(String n) { /* Code */ }
        public String getName() { /* Code */ }
    }
\end{verbatim}

And in C++, a typical class would look like: 
\begin{verbatim}
    class Student {
        public: 
            static int numStudents; 

            Student(string n);
            
            void setName(string n);
            string getName() const; 

        private: 
            string name; 
    }

    int Student::numStudents = 0;
    Student::Student(string n) { /* Code */ }
    void Student::setName(string n) { /* Code */ }
    string Student::getName() const { /* Code */ }
\end{verbatim}

There are several notable differences: 
\begin{itemize}
    \item \textbf{Modifiers:} In Java, if you want your method or instance variable to have an access modifier, you explicitly state the access modifier. In C++, you have a region for your access modifier. That is, there is a \code{public} region, \code{private} region, etc. Any methods or instance variables listed under these regions will take on that access modifier. For instance, \code{setName} is in the \code{public} region, so \code{setName} is public.
    \item \textbf{Implementation:} In Java, directly after declaring a method or constructor in a class, we need to provide the implementation code. In C++, we can ``declare'' the methods and the constructor, and then outside of the class we can implement the methods.
\end{itemize}
Now, consider the following C++ code: 
\begin{verbatim}
    class Point {
        private: 
            int x; 
            int y;
        
        public:
            Point(int i, int j);
    }

    Point::Point(int i, int j) {
        x = i;
        y = j;
    }
\end{verbatim}
Here, we're initializing the \code{x} and \code{y} instance variables directly from the constructor implementation. However, we can initialize these instance variables directly like so: 
\begin{verbatim}
    class Point {
        private: 
            int x; 
            int y;
        
        public:
            Point(int i, int j);
    }

    Point::Point(int i, int j) : x(i), y(j) {}
\end{verbatim}
This is called the \textbf{member initializer list}.

\subsubsection{Source vs. Header Files}
Consider the following class: 
\begin{verbatim}
    class Student {
        public: 
            static int numStudents;
            Student(string n);
        
        private: 
            string name; 
    }

    int Student::numStudents = 0;
    Student::Student(string n) : name(n) {
        numStudents++;
    }
\end{verbatim}
We can choose to break this up into two separate files; a \textbf{source} (usually \code{.cpp}) file and a \textbf{header} (usually \code{.h}) file. The header file contains the class and the method \emph{declaration}; the source file contains the implementations for those methods. So, the above code can be written like so: 
\begin{verbatim}
    // The header file 
    // Student.h
    class Student {
        public: 
            static int numStudents;
            Student(string n);
        
        private: 
            string name; 
    }

    // The source file 
    // Student.cpp 
    int Student::numStudents = 0;
    Student::Student(string n) : name(n) {
        numStudents++;
    }
\end{verbatim}

\subsection{Memory Diagrams}
Consider the following Java code: 
\begin{verbatim}
    Student s1 = new Student("Niema");
    Student s2 = s1;
\end{verbatim}
Here, \code{s1} is a \emph{reference} to a \code{Student} object. This \code{Student} object contains a \emph{reference} to a \code{string} object with the content \code{Niema}. That is: 
\begin{verbatim}
    Student object
    |----------|
    | |----|   |   (Reference)  |-------|
    | |name|------------------> | Niema |
    | |----|   |                |-------|
    |----------|   <------      String object
       /|\                \
        |                  \
        |                   \ (Reference)
        |                   |
        | (Reference)       |
    s1 -/                   s2
\end{verbatim} 
It also follows that \code{s2} is a reference to the same object that \code{s1} is referring to. 

\bigskip 

Now, consider the following C++ code: 
\begin{verbatim}
    Student s1("Niema");
    Student s2 = s1;
\end{verbatim}
Here, \code{s1} is a \code{Student} \emph{object}. The \code{Student} object contains a \code{string} object with the content \code{Niema}. That is:
\begin{verbatim}
    |-----------------|     |-----------------|
    | |-----------|   |     | |-----------|   |
    | |name: Niema|   |     | |name: Niema|   |
    | |-----------|   |     | |-----------|   |
    |  string object  |     |  string object  |
    |-----------------|     |-----------------|
    Student object          Student object
       s1                       s2
\end{verbatim} 
Additionally, when we assign \code{s1} to \code{s2}, we actually make a copy of said object. So, \code{s2} is its own object; it does not share a reference with \code{s1}.

\bigskip 

In other words, in Java, \code{s1} and \code{s2} are both references to the same object; in C++, \code{s1} \emph{is} the object and \code{s2} is \emph{another} object.

\subsubsection{References}
Consider the following C++ code: 
\begin{verbatim}
    Student s1 = Student("Niema");
    Student & s2 = s1;
    Student s3 = s2;
\end{verbatim}
The memory diagram looks like this: 
\begin{verbatim}
    |-----------------|     |-----------------|
    | |-----------|   |     | |-----------|   |
    | |name: Niema|   |     | |name: Niema|   |
    | |-----------|   |     | |-----------|   |
    |  string object  |     |  string object  |
    |-----------------|     |-----------------|
    Student object          Student object 
       s1      s2               s3
\end{verbatim} 
Here, \code{s2} can be seen as \emph{another} way to call \code{s1} (think of \code{s2} as another name for \code{s1}). \code{s3} would be a copy of \code{s1}. 

\subsubsection{Pointers}
Pointers are similar to Java references. Consider the following C++ code: 
\begin{verbatim}
    Student s = Student("Niema");
    // * in this case means pointer 
    // & means memory address
    // So, ptr stores a memory address to some object. In other words, 
    // it points to the object s. 
    Student* ptr = &s; 
    Student** ptrPtr = &ptr; 
\end{verbatim}
The memory diagram would look like: 
\begin{verbatim}
    Mem. Address: 9500 
    |-----------------|
    | |-----------|   |       |-----------|       |-----------|
    | |name: Niema|   |  <--- |    9500   |  <--- |           |
    | |-----------|   |       |-----------|       |-----------|
    |  string object  |       Student* (pointer)   Student** (pointer to pointer) 
    |-----------------|           ptr                  ptrPtr
    Student object      
       s
\end{verbatim} 
If we wanted to access an object through a pointer, we can do this in several ways. 
\begin{enumerate}
    \item Deferencing a pointer. 
    \begin{verbatim}
        // * in this case dereferences the pointer
        // Think of the * as following the arrow  
        (*ptr).name; 
    \end{verbatim}

    \item Arrow dereferencing. 
    \begin{verbatim}
        // ptr->x is the same thing as (*ptr).x
        ptr->name; 
    \end{verbatim}
\end{enumerate}

\subsubsection{Memory Management}
Consider the following C++ code: 
\begin{verbatim}
    Student s1 = Student("Niema");
    Student* s2 = new Student("Ryan");
\end{verbatim}
The corresponding memory diagram is: 
\begin{verbatim}
    |-----------------|     |-----------------|
    | |-----------|   |     | |-----------|   |
    | |name: Niema|   |     | |name: Ryan |   |
    | |-----------|   |     | |-----------|   |
    |  string object  |     |  string object  |
    |-----------------|     |-----------------|
    Student object          Student object 
       s1                                 /|\
                                           |
                                           |
                                           |
                                |------|   |
                                |      | --/
                                |------|
                                Student* (pointer)
                                s2
\end{verbatim}
Here, \code{s1} is allocated on the \emph{stack}; once the method returns, \code{s1} is automatically destroyed. 

\bigskip 

\code{s2} is allocated through the \code{new} keyword. This is known as dynamic memory allocation. So, \code{s2} is a pointer to the newly allocated memory. Because this object was created using the \code{new} keyword, we need to deallocate it ourselves. To do so, we need to explicitly call \code{delete} on this object: 
\begin{verbatim}
    delete s2; 
\end{verbatim}
\code{delete} takes in a memory address (i.e. pointer). This is very similar to \code{free} (in C). If we don't free this, we run into what is called a \textbf{memory leak}. 

\subsection{Constant Keyword}
In C++, the \code{const} keyword means that the variable can never be reassigned. Consider the following: 
\begin{verbatim}
    const int a = 42; 
    int const b = 42;
\end{verbatim}
If we tried reassigning \code{a} (e.g. \code{a = 41;}), we would get a compiler error. 

\bigskip

The second line (\code{int const}) is identical to the first line. 


\subsubsection{\code{const} and Pointers}
Consider the following C++ code: 
\begin{verbatim}
    int a = 42; 
    const int* ptr1 = &a; 
    const int* ptr2 = &a; 
\end{verbatim}




\end{document}